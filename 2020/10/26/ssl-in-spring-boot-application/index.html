<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>SSL in a Spring Boot application</title>
  <meta name="description" content="SSL (or its successor TLS) is a communication protocol used to transfer encrypted data over a network. It involves Authentication of the entities and Encryption/Decryption of data being shared between a web server and client. This article talks about SSL and how we can setup it on a spring boot application. Authentication Authentication of entities on a network is established using digital certificate. Typically in a one way handshake, the server has a keystore which holds a private key, a public key and a x509 certificate where the public and private keys form a pair, private key is used for decryption and public key is used for encryption of data. There is a truststore which stores all trusted certificates signed by CA. Client/Server refers to it to validate a certificate. When a client sends a request to server, the server responds back with the certificate and the public key. Client authenticates the server by validating if the certificate received is present in truststore or not. In many cases the server would also validate its client that process is referred to as two way handshake. Encryption Once the server is found authentic the client generates a shared key and encrypts it using server’s public key. It sends the encrypted shared key to the server where the server decrypts it using its private key. Now both server and client have a shared session key which can be used for encryption and decryption of data being transferred between them. The server presents its public key and certificates from keystore to the client, the client validates the certificate is present in truststore so that the server can be trusted. Setting up SSL in spring boot application Generating the keystore and truststore # Generate a private key openssl genrsa -des3 -out privatekey.key 1024 # Generate Certificate signeding Request (CSR) # CN should be the domain-name or localhost for running in local openssl req -new -key privatekey.key -out csrfile.csr # Generate self signed certificate openssl x509 -req -days 365 -in csrfile.csr -signkey privatekey.key -out public.crt # Import the self signed certificate to a truststore file keytool -import -file public.crt -alias exampleCA -keystore truststore.jks # Import the keypair and certificates to a keystore file openssl pkcs12 -export -in public.crt -inkey privatekey.key -certfile public.crt -name &quot;certs&quot; -out keystore.p12 # to convert p12 to jks keytool -importkeystore -srckeystore keystore.p12 -srcstoretype pkcs12 -destkeystore keystore.jks -deststoretype JKS Configuring the server Once the certificates are generated copy the truststore and keystore .jks files to the classpath of your spring boot application. Here I am using spring 2.3.4.RELEASE, spring-security dependency is required in the pom file. &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Add a WebSecurityConfig extending WebSecurityConfigurerAdapter class to allow request on https and block any request coming from a non-secure HTTP channel. @Configuration @EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.requiresChannel() .anyRequest() .requiresSecure(); } } Update the spring application yaml file as below. server: port: 8443 ssl: enabled: true key-store: classpath:keystore.jks key-store-password: password trust-store: classpath:truststore.jks trust-store-password: password client-auth: need Test it out Create one example controller: @RestController @RequestMapping(&quot;/ssl&quot;) public class ExampleController { @RequestMapping(path=&quot;/example&quot;, method= RequestMethod.GET) public String apiRequest() { return &quot;Successfully Validated!&quot;; } } In the application tests, create a RestClient configuration which would access the server with ssl. SSLContextBuilder and HttpClients are part of apache httpclients library. @Configuration public class RestClientTest { private String password = &quot;password&quot;; @Bean public RestTemplate restTemplate(RestTemplateBuilder builder) throws Exception { SSLContext sslContext = SSLContextBuilder .create() .loadKeyMaterial(ResourceUtils.getFile(&quot;classpath:keystore.jks&quot;), password.toCharArray(), password.toCharArray()) .loadTrustMaterial(ResourceUtils.getFile(&quot;classpath:truststore.jks&quot;), password.toCharArray()) .build(); return builder .requestFactory( ()-&amp;gt;new HttpComponentsClientHttpRequestFactory( HttpClients.custom() .setSSLContext(sslContext) .build() ) ) .build(); } } A sample junit test to test the endpoint. Note the host url should have https protocol or it will fail during SSL handshake. @RunWith(SpringRunner.class) @SpringBootTest( classes = Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT ) public class ApplicationTests { public ApplicationTests(){ } @LocalServerPort private int port; @Autowired private RestTemplate restTemplate; @Test public void withSSL() { String response = restTemplate.getForObject(&quot;https://localhost:&quot; + port + &quot;/ssl/example&quot;, String.class); Assert.assertEquals(&quot;Successfully Validated!&quot;, response); } }">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://akatsuki06.github.io/2020/10/26/ssl-in-spring-boot-application/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Blog" href="https://akatsuki06.github.io/feed.xml">

  

  
  <meta property="og:title" content="SSL in a Spring Boot application">
  <meta property="og:site_name" content="Blog">
  <meta property="og:url" content="https://akatsuki06.github.io/2020/10/26/ssl-in-spring-boot-application/">
  <meta property="og:description" content="SSL (or its successor TLS) is a communication protocol used to transfer encrypted data over a network. It involves Authentication of the entities and Encryption/Decryption of data being shared between a web server and client. This article talks about SSL and how we can setup it on a spring boot application. Authentication Authentication of entities on a network is established using digital certificate. Typically in a one way handshake, the server has a keystore which holds a private key, a public key and a x509 certificate where the public and private keys form a pair, private key is used for decryption and public key is used for encryption of data. There is a truststore which stores all trusted certificates signed by CA. Client/Server refers to it to validate a certificate. When a client sends a request to server, the server responds back with the certificate and the public key. Client authenticates the server by validating if the certificate received is present in truststore or not. In many cases the server would also validate its client that process is referred to as two way handshake. Encryption Once the server is found authentic the client generates a shared key and encrypts it using server’s public key. It sends the encrypted shared key to the server where the server decrypts it using its private key. Now both server and client have a shared session key which can be used for encryption and decryption of data being transferred between them. The server presents its public key and certificates from keystore to the client, the client validates the certificate is present in truststore so that the server can be trusted. Setting up SSL in spring boot application Generating the keystore and truststore # Generate a private key openssl genrsa -des3 -out privatekey.key 1024 # Generate Certificate signeding Request (CSR) # CN should be the domain-name or localhost for running in local openssl req -new -key privatekey.key -out csrfile.csr # Generate self signed certificate openssl x509 -req -days 365 -in csrfile.csr -signkey privatekey.key -out public.crt # Import the self signed certificate to a truststore file keytool -import -file public.crt -alias exampleCA -keystore truststore.jks # Import the keypair and certificates to a keystore file openssl pkcs12 -export -in public.crt -inkey privatekey.key -certfile public.crt -name &quot;certs&quot; -out keystore.p12 # to convert p12 to jks keytool -importkeystore -srckeystore keystore.p12 -srcstoretype pkcs12 -destkeystore keystore.jks -deststoretype JKS Configuring the server Once the certificates are generated copy the truststore and keystore .jks files to the classpath of your spring boot application. Here I am using spring 2.3.4.RELEASE, spring-security dependency is required in the pom file. &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; Add a WebSecurityConfig extending WebSecurityConfigurerAdapter class to allow request on https and block any request coming from a non-secure HTTP channel. @Configuration @EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.requiresChannel() .anyRequest() .requiresSecure(); } } Update the spring application yaml file as below. server: port: 8443 ssl: enabled: true key-store: classpath:keystore.jks key-store-password: password trust-store: classpath:truststore.jks trust-store-password: password client-auth: need Test it out Create one example controller: @RestController @RequestMapping(&quot;/ssl&quot;) public class ExampleController { @RequestMapping(path=&quot;/example&quot;, method= RequestMethod.GET) public String apiRequest() { return &quot;Successfully Validated!&quot;; } } In the application tests, create a RestClient configuration which would access the server with ssl. SSLContextBuilder and HttpClients are part of apache httpclients library. @Configuration public class RestClientTest { private String password = &quot;password&quot;; @Bean public RestTemplate restTemplate(RestTemplateBuilder builder) throws Exception { SSLContext sslContext = SSLContextBuilder .create() .loadKeyMaterial(ResourceUtils.getFile(&quot;classpath:keystore.jks&quot;), password.toCharArray(), password.toCharArray()) .loadTrustMaterial(ResourceUtils.getFile(&quot;classpath:truststore.jks&quot;), password.toCharArray()) .build(); return builder .requestFactory( ()-&amp;gt;new HttpComponentsClientHttpRequestFactory( HttpClients.custom() .setSSLContext(sslContext) .build() ) ) .build(); } } A sample junit test to test the endpoint. Note the host url should have https protocol or it will fail during SSL handshake. @RunWith(SpringRunner.class) @SpringBootTest( classes = Application.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT ) public class ApplicationTests { public ApplicationTests(){ } @LocalServerPort private int port; @Autowired private RestTemplate restTemplate; @Test public void withSSL() { String response = restTemplate.getForObject(&quot;https://localhost:&quot; + port + &quot;/ssl/example&quot;, String.class); Assert.assertEquals(&quot;Successfully Validated!&quot;, response); } }">
  
  
  <meta name="twitter:card" content="summary">
  
  <meta name="twitter:title" content="SSL in a Spring Boot application">
  <meta name="twitter:description" content="SSL (or its successor TLS) is a communication protocol used to transfer encrypted data over a network. It involves Authentication of the entities and Encryption/Decryption of data being shared betw...">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css?family=Poppins:wght,400i,700&amp;display=swap" rel="stylesheet">


  
  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-105829162-2', 'auto');
    ga('send', 'pageview');

  </script>


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Blog</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/archives/">archives</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">SSL in a Spring Boot application</h1>
    
    <p class="post-meta"><time datetime="2020-10-26T09:40:56+00:00" itemprop="datePublished">Oct 26, 2020</time> •
  
    
    
      
    
      
    
      
    
      
        <a href="/categories/ssl/">ssl</a>,
      
    
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/security/">security</a>,
      
    
      
    
      
    
      
    
  
    
    
      
    
      
    
      
    
      
    
      
    
      
        <a href="/categories/springboot/">springboot</a>
      
    
      
    
      
    
  



</p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>SSL (or its successor TLS) is a communication  protocol used to transfer encrypted data over a network. It involves  <ins>Authentication</ins> of the entities and <ins>Encryption/Decryption</ins>  of data being shared between a web server and client.</p>

<p>This article talks about SSL and how we can setup it on a spring boot application.</p>

<h3><strong>Authentication</strong></h3>

<p>Authentication of entities on a network is established using digital certificate. Typically in a one way handshake, the server has a keystore which holds a private key, a public key and a <em>x509</em>  certificate where the public and private keys form a pair, private key is used for decryption and public key is used for encryption of data.</p>

<p>There is a truststore which stores all trusted certificates signed by CA. Client/Server refers to it to validate a certificate.</p>

<p>When a client sends a request to server, the server responds back with the certificate and the public key.</p>

<p>Client authenticates the server by validating if the certificate received is present in truststore or not. In many cases the server would also validate its client that process is referred to as two way handshake.</p>

<h3><strong>Encryption</strong></h3>

<p>Once the server is found authentic the client generates a shared key and encrypts it using server’s public key. It sends the encrypted shared key to the server where the server decrypts it using its private key. Now both server and client have a shared session key which can be used for encryption and decryption of data being transferred between them.</p>

<p><img src="https://user-images.githubusercontent.com/16136908/97805333-72f2c500-1c7b-11eb-83a3-49ce02376c9b.png" alt="image" /></p>

<blockquote>
  <blockquote>
    <p>The server presents its public key and certificates from keystore to the client, the client validates the certificate is present in truststore so that the server can be trusted.</p>
  </blockquote>
</blockquote>

<p><br /></p>

<h2>Setting up SSL in spring boot application</h2>

<h3>Generating the keystore and truststore</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c"># Generate a private key</span>
 openssl genrsa <span class="nt">-des3</span> <span class="nt">-out</span> privatekey.key 1024

<span class="c"># Generate Certificate signeding Request (CSR)</span>
<span class="c"># CN should be the domain-name or localhost for running in local</span>
openssl req <span class="nt">-new</span> <span class="nt">-key</span> privatekey.key <span class="nt">-out</span> csrfile.csr

<span class="c"># Generate self signed certificate</span>
openssl x509 <span class="nt">-req</span> <span class="nt">-days</span> 365 <span class="nt">-in</span> csrfile.csr <span class="nt">-signkey</span> privatekey.key <span class="nt">-out</span> public.crt

<span class="c"># Import the self signed certificate to a truststore file</span>
keytool <span class="nt">-import</span> <span class="nt">-file</span> public.crt <span class="nt">-alias</span> exampleCA <span class="nt">-keystore</span> truststore.jks

<span class="c"># Import the keypair and certificates to a keystore file</span>
openssl pkcs12 <span class="nt">-export</span> <span class="nt">-in</span> public.crt <span class="nt">-inkey</span> privatekey.key <span class="nt">-certfile</span> public.crt <span class="nt">-name</span> <span class="s2">"certs"</span> <span class="nt">-out</span> keystore.p12

<span class="c"># to convert p12 to jks</span>
keytool <span class="nt">-importkeystore</span> <span class="nt">-srckeystore</span> keystore.p12 <span class="nt">-srcstoretype</span> pkcs12 <span class="nt">-destkeystore</span> keystore.jks <span class="nt">-deststoretype</span> JKS

</code></pre></div></div>

<h2>Configuring the server</h2>

<p>Once the certificates are generated copy the truststore and keystore .jks files to the classpath of your spring boot application.
Here I am using spring <code class="language-plaintext highlighter-rouge">2.3.4.RELEASE</code>, spring-security dependency is required in the pom file.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nt">&lt;dependency&gt;</span>
      <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
      <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-security<span class="nt">&lt;/artifactId&gt;</span>
    <span class="nt">&lt;/dependency&gt;</span>

</code></pre></div></div>

<p>Add a <code class="language-plaintext highlighter-rouge">WebSecurityConfig</code> extending <code class="language-plaintext highlighter-rouge">WebSecurityConfigurerAdapter</code> class to allow request on https
and block any request coming from a non-secure HTTP channel.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="nd">@EnableWebSecurity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">WebSecurityConfig</span> <span class="kd">extends</span> <span class="nc">WebSecurityConfigurerAdapter</span> <span class="o">{</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">configure</span><span class="o">(</span><span class="nc">HttpSecurity</span> <span class="n">http</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="n">http</span><span class="o">.</span><span class="na">requiresChannel</span><span class="o">()</span>
                <span class="o">.</span><span class="na">anyRequest</span><span class="o">()</span>
                <span class="o">.</span><span class="na">requiresSecure</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Update the spring application yaml file as below.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">server</span><span class="pi">:</span>
  <span class="na">port</span><span class="pi">:</span> <span class="m">8443</span>
  <span class="na">ssl</span><span class="pi">:</span>
    <span class="na">enabled</span><span class="pi">:</span> <span class="no">true</span>
    <span class="na">key-store</span><span class="pi">:</span> <span class="s">classpath:keystore.jks</span>
    <span class="na">key-store-password</span><span class="pi">:</span> <span class="s">password</span>
    <span class="na">trust-store</span><span class="pi">:</span> <span class="s">classpath:truststore.jks</span>
    <span class="na">trust-store-password</span><span class="pi">:</span> <span class="s">password</span>
    <span class="na">client-auth</span><span class="pi">:</span> <span class="s">need</span>

</code></pre></div></div>

<h3>Test it out</h3>

<p>Create one example controller:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/ssl"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExampleController</span> <span class="o">{</span>

    <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">path</span><span class="o">=</span><span class="s">"/example"</span><span class="o">,</span> <span class="n">method</span><span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">apiRequest</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">"Successfully Validated!"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>In the application tests, create a RestClient configuration which would access the server with ssl.
<code class="language-plaintext highlighter-rouge">SSLContextBuilder</code> and <code class="language-plaintext highlighter-rouge">HttpClients</code> are part of apache httpclients library.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RestClientTest</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"password"</span><span class="o">;</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">RestTemplate</span> <span class="nf">restTemplate</span><span class="o">(</span><span class="nc">RestTemplateBuilder</span> <span class="n">builder</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">SSLContext</span> <span class="n">sslContext</span> <span class="o">=</span> <span class="nc">SSLContextBuilder</span>
                <span class="o">.</span><span class="na">create</span><span class="o">()</span>
                <span class="o">.</span><span class="na">loadKeyMaterial</span><span class="o">(</span><span class="nc">ResourceUtils</span><span class="o">.</span><span class="na">getFile</span><span class="o">(</span><span class="s">"classpath:keystore.jks"</span><span class="o">),</span>
                                         <span class="n">password</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">(),</span> <span class="n">password</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span>
                <span class="o">.</span><span class="na">loadTrustMaterial</span><span class="o">(</span><span class="nc">ResourceUtils</span><span class="o">.</span><span class="na">getFile</span><span class="o">(</span><span class="s">"classpath:truststore.jks"</span><span class="o">),</span> <span class="n">password</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span>
                <span class="o">.</span><span class="na">build</span><span class="o">();</span>

        <span class="k">return</span> <span class="n">builder</span>
                <span class="o">.</span><span class="na">requestFactory</span><span class="o">(</span>
                        <span class="o">()-&gt;</span><span class="k">new</span> <span class="nc">HttpComponentsClientHttpRequestFactory</span><span class="o">(</span>
                                <span class="nc">HttpClients</span><span class="o">.</span><span class="na">custom</span><span class="o">()</span>
                                <span class="o">.</span><span class="na">setSSLContext</span><span class="o">(</span><span class="n">sslContext</span><span class="o">)</span>
                                <span class="o">.</span><span class="na">build</span><span class="o">()</span>
                        <span class="o">)</span>
                <span class="o">)</span>
                <span class="o">.</span><span class="na">build</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>A sample junit test to test the endpoint. Note the host url should have <code class="language-plaintext highlighter-rouge">https</code> protocol or it will fail during SSL handshake.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@RunWith</span><span class="o">(</span><span class="nc">SpringRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="nd">@SpringBootTest</span><span class="o">(</span>
    <span class="n">classes</span> <span class="o">=</span> <span class="nc">Application</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
    <span class="n">webEnvironment</span> <span class="o">=</span> <span class="nc">SpringBootTest</span><span class="o">.</span><span class="na">WebEnvironment</span><span class="o">.</span><span class="na">RANDOM_PORT</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ApplicationTests</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">ApplicationTests</span><span class="o">(){</span>
    <span class="o">}</span>

    <span class="nd">@LocalServerPort</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">port</span><span class="o">;</span>

    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">RestTemplate</span> <span class="n">restTemplate</span><span class="o">;</span>

    <span class="nd">@Test</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">withSSL</span><span class="o">()</span> <span class="o">{</span>
      <span class="nc">String</span> <span class="n">response</span> <span class="o">=</span> <span class="n">restTemplate</span><span class="o">.</span><span class="na">getForObject</span><span class="o">(</span><span class="s">"https://localhost:"</span> <span class="o">+</span> <span class="n">port</span> <span class="o">+</span> <span class="s">"/ssl/example"</span><span class="o">,</span> <span class="nc">String</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
      <span class="nc">Assert</span><span class="o">.</span><span class="na">assertEquals</span><span class="o">(</span><span class="s">"Successfully Validated!"</span><span class="o">,</span> <span class="n">response</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span>

</code></pre></div></div>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      

&copy; akatsuki06<br>
 Powered by <a href="https://pages.github.com/">Github Pages</a> <br>Theme by <a href="https://github.com/yous/whiteglass">Whiteglass</a> <br>
 <!-- Subscribe via <a href="https://akatsuki06.github.io/feed.xml">RSS</a> -->

    </p>

  </div>

</footer>


  </body>

</html>
